# Volatility
#
# Authors:
# Michael Hale Ligh <michael.ligh@mnin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details. 
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
#

import volatility.obj as obj
import volatility.utils as utils
import volatility.win32.tasks as tasks
import volatility.plugins.malware as malware

class ZeusScan1(malware.ImpScan):
    "Scan for and dump Zeus RC4 keys"

    def __init__(self, config, *args):
        malware.ImpScan.__init__(self, config, *args)
        config.remove_option("ADDR")
        config.remove_option("SIZE")
        config.remove_option("SCAN")
        config.remove_option("UNSAFE")

    def calculate(self):
        addr_space = malware.get_malware_space(self._config)

        # temporary fix until issue 144 is resolved (http://code.google.com/p/volatility/issues/detail?id=144)
        addr_space.profile.add_types({
            '_MMVAD_FLAGS' : [ 0x4, {
            'CommitCharge' : [ 0x0, ['BitField', dict(start_bit = 0, end_bit = 19)]],
            'PhysicalMapping' : [ 0x0, ['BitField', dict(start_bit = 19, end_bit = 20)]],
            'ImageMap' : [ 0x0, ['BitField', dict(start_bit = 20, end_bit = 21)]],
            'UserPhysicalPages' : [ 0x0, ['BitField', dict(start_bit = 21, end_bit = 22)]],
            'NoChange' : [ 0x0, ['BitField', dict(start_bit = 22, end_bit = 23)]],
            'WriteWatch' : [ 0x0, ['BitField', dict(start_bit = 23, end_bit = 24)]],
            'Protection' : [ 0x0, ['BitField', dict(start_bit = 24, end_bit = 29)]],
            'LargePages' : [ 0x0, ['BitField', dict(start_bit = 29, end_bit = 30)]],
            'MemCommit' : [ 0x0, ['BitField', dict(start_bit = 30, end_bit = 31)]],    
            'PrivateMemory' : [ 0x0, ['BitField', dict(start_bit = 31, end_bit = 32)]],
            }]})
    
        RC4_KEYSIZE = 0x102
    
        # cycle through the active processes
        for p in self.filter_tasks(tasks.pslist(addr_space)):
    
            # get the process address space
            ps_ad = p.get_process_address_space()
            if ps_ad == None:
                continue
    
            # enumerate DLLs (inherited from DllList)
            mods = p.list_modules()

            # traverse the VAD
            for vad in p.VadRoot.traverse():

                if vad == None:
                    continue

                # only looking for short VADs (non-memory mapped)
                if (vad.Tag != "VadS"):
                    continue

                # only looking for private, virtually-alocated memory
                if vad.u.VadFlags.PrivateMemory == 0:
                    continue

                # we want the memory to be executable, but right now we can only 
                # "see" the original protection not the current protection...and
                # the original protection can be anything. this version of zeus 
                # happens to use PAGE_NOACCESS so that's what we'll look for instead.
                # see http://code.google.com/p/volatility/issues/detail?id=143. 
                if malware.PROTECT_FLAGS[vad.Flags.Protection >> 24] != 'PAGE_NOACCESS':
                    continue

                ## for Volatility 2.0 use the following
                start = vad.StartingVpn << 12
                end   = ((vad.EndingVpn + 1) << 12) - 1
                data  = malware.get_vad_data(ps_ad, start, end) 
                ## For Volatility >= 2.1 use the following
                #start = vad.get_start()
                #end   = vad.get_end()
                #data  = vad.get_data()

                # check for PE headers at the base 
                if data[0:2] != 'MZ':
                    continue

                # locate the winsock2 module
                winsock = malware.find_module_by_name(mods, "ws2_32.dll")

                if winsock == None:
                    continue

                # resolve the address of closesocket export
                closesocket = winsock.getprocaddress("closesocket")

                if closesocket == None:
                    continue

                # scan for calls to imported functions (inherited from ImpScan)
                calls = list(self.call_scan(ps_ad, data, start))

                for (addr_of_call, const, call_dest) in calls:

                    if call_dest != closesocket:
                        continue

                    # read the DWORD directly after closesocket 
                    struct_base = obj.Object('Pointer', offset = const + 4, vm = ps_ad) 

                    # to be valid, it must point within the vad segment 
                    if (struct_base < start) or (struct_base > (start + end)):
                        continue

                    # grab the key data
                    key = ps_ad.read(struct_base + 0x2a, RC4_KEYSIZE)

                    # greg's sanity check
                    if len(key) != RC4_KEYSIZE or key[-2:] != "\x00\x00":
                        continue

                    yield p, struct_base, key

    def render_text(self, outfd, data):
        
        for p, struct_base, key in data:
            hex = "\n".join(["{0:#010x}  {1:<48}  {2}".format(struct_base + 0x2a + o, h, ''.join(c)) for o, h, c in utils.Hexdump(key)])
            outfd.write("Process: {0} {1}\n".format(p.UniqueProcessId, p.ImageFileName))
            outfd.write(hex)
            outfd.write("\n")
